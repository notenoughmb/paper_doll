[gd_resource type="Resource" load_steps=11 format=3 uid="uid://bs2ky8wg65wq4"]

[sub_resource type="GDScript" id="GDScript_mb1mj"]
script/source = "@tool
## Special inheritance class for [FuncGodotFGDSolidClass] and [FuncGodotFGDPointClass] entity definitions. Useful for adding shared or common properties and descriptions.
class_name FuncGodotFGDBaseClass
extends FuncGodotFGDEntityClass

func _init() -> void:
	prefix = \"@BaseClass\"
"

[sub_resource type="Resource" id="Resource_74nl1"]
script = SubResource("GDScript_mb1mj")
classname = "Phong"
description = "Phong shading options for SolidClass geometry."
func_godot_internal = false
base_classes = Array[Resource]([])
class_properties = {
"_phong": {
"Disabled": 0,
"Smooth shading": 1
},
"_phong_angle": 89.0
}
class_property_descriptions = {
"_phong": ["Phong shading", 0],
"_phong_angle": "Phong smoothing angle"
}
meta_properties = {
"color": Color(0.8, 0.8, 0.8, 1),
"size": AABB(-8, -8, -8, 8, 8, 8)
}
node_class = ""
name_property = ""

[sub_resource type="GDScript" id="GDScript_ly3ma"]
script/source = "@tool
## FGD SolidClass entity definition, used to define brush entities.
## A [MeshInstance3D] will be generated by FuncGodotMap according to this definition's Visual Build settings. If FuncGodotFGDSolidClass [member node_class] inherits [CollisionObject3D] then one or more [CollisionShape3D] nodes will be generated according to Collision Build settings.
class_name FuncGodotFGDSolidClass
extends FuncGodotFGDEntityClass

enum SpawnType {
	WORLDSPAWN = 0, ## Is worldspawn
	MERGE_WORLDSPAWN = 1, ## Should be combined with worldspawn
	ENTITY = 2, ## Is its own separate entity
}

enum OriginType {
	AVERAGED = 0, ## Use averaged brush vertices for center position. This is the old Qodot behavior.
	ABSOLUTE = 1, ## Use `origin` class property in global coordinates as the center position.
	RELATIVE = 2, ## Calculate center position using `origin` class property as an offset to the entity's bounding box center.
	BRUSH = 3, ## Calculate center position based on the bounding box center of all brushes using the 'origin' texture specified in the [FuncGodotMapSettings].
	BOUNDS_CENTER = 4, ## Use the center of the entity's bounding box for center position. This is the default option and recommended for most entities.
	BOUNDS_MINS = 5, ## Use the lowest bounding box coordinates for center position. This is standard Quake and Half-Life brush entity behavior.
	BOUNDS_MAXS = 6, ## Use the highest bounding box coordinates for center position.
}

enum CollisionShapeType {
	NONE, ## No collision shape is built. Useful for decorative geometry like vines, hanging wires, grass, etc...
	CONVEX, ## Will build a Convex CollisionShape3D for each brush used to make this Solid Class. Required for non-[StaticBody3D] nodes like [Area3D].
	CONCAVE ## Should have a concave collision shape
}

## Controls whether this Solid Class is the worldspawn, is combined with the worldspawn, or is spawned as its own free-standing entity.
@export var spawn_type: SpawnType = SpawnType.ENTITY
## Controls how this Solid Class determines its center position. Only valid if [member spawn_type] is set to ENTITY.
@export var origin_type: OriginType = OriginType.BOUNDS_CENTER

@export_group(\"Visual Build\")
## Controls whether a [MeshInstance3D] is built for this Solid Class.
@export var build_visuals : bool = true
## Sets generated [MeshInstance3D] to be available for UV2 unwrapping after [FuncGodotMap] build. Utilized in baked lightmapping.
@export var use_in_baked_light : bool = true
## Shadow casting setting allows for further lightmapping customization.
@export var shadow_casting_setting : GeometryInstance3D.ShadowCastingSetting = GeometryInstance3D.SHADOW_CASTING_SETTING_ON
## Automatically build [OccluderInstance3D] for this entity.
@export var build_occlusion : bool = false
## This Solid Class' [MeshInstance3D] will only be visible for [Camera3D]s whose cull mask includes any of these render layers.
@export_flags_3d_render var render_layers: int = 1

@export_group(\"Collision Build\")
## Controls how collisions are built for this Solid Class.
@export var collision_shape_type: CollisionShapeType = CollisionShapeType.CONVEX
## The physics layers this Solid Class can be detected in.
@export_flags_3d_physics var collision_layer: int = 1
## The physics layers this Solid Class scans.
@export_flags_3d_physics var collision_mask: int = 1
## The priority used to solve colliding when penetration occurs. The higher the priority is, the lower the penetration into the Solid Class will be. This can for example be used to prevent the player from breaking through the boundaries of a level.
@export var collision_priority: float = 1.0
## The collision margin for the Solid Class' collision shapes. Not used in Godot Physics. See [Shape3D] for details.
@export var collision_shape_margin: float = 0.04

@export_group(\"Scripting\")
## An optional script file to attach to the node generated on map build.
@export var script_class: Script

func _init():
	prefix = \"@SolidClass\"
"

[sub_resource type="Resource" id="Resource_4tp8u"]
script = SubResource("GDScript_ly3ma")
spawn_type = 0
origin_type = 4
build_visuals = true
use_in_baked_light = true
shadow_casting_setting = 1
build_occlusion = true
render_layers = 1
collision_shape_type = 1
collision_layer = 1
collision_mask = 0
collision_priority = 1.0
collision_shape_margin = 0.04
classname = "worldspawn"
description = "Default static world geometry. Builds a StaticBody3D with a single MeshInstance3D and a single convex CollisionShape3D shape. Also builds Occluder3D to aid in render culling of other VisualInstance3D nodes."
func_godot_internal = false
base_classes = Array[Resource]([])
class_properties = {}
class_property_descriptions = {}
meta_properties = {
"color": Color(0.8, 0.8, 0.8, 1)
}
node_class = "StaticBody3D"
name_property = ""

[sub_resource type="Resource" id="Resource_c64xc"]
script = SubResource("GDScript_ly3ma")
spawn_type = 2
origin_type = 4
build_visuals = true
use_in_baked_light = true
shadow_casting_setting = 1
build_occlusion = true
render_layers = 1
collision_shape_type = 2
collision_layer = 1
collision_mask = 0
collision_priority = 1.0
collision_shape_margin = 0.04
classname = "func_geo"
description = "Static collidable geometry. Builds a StaticBody3D with a MeshInstance3D, a single concave CollisionShape3D, and an OccluderInstance3D."
func_godot_internal = false
base_classes = Array[Resource]([SubResource("Resource_74nl1")])
class_properties = {}
class_property_descriptions = {}
meta_properties = {
"color": Color(0.8, 0.8, 0.8, 1)
}
node_class = "StaticBody3D"
name_property = ""

[sub_resource type="Resource" id="Resource_qclf3"]
script = SubResource("GDScript_ly3ma")
spawn_type = 2
origin_type = 4
build_visuals = true
use_in_baked_light = true
shadow_casting_setting = 1
build_occlusion = false
render_layers = 1
collision_shape_type = 2
collision_layer = 1
collision_mask = 0
collision_priority = 1.0
collision_shape_margin = 0.04
classname = "func_detail"
description = "Static collidable geometry. Builds a StaticBody3D with a MeshInstance3D and a single concave CollisionShape3D. Does not occlude other VisualInstance3D nodes."
func_godot_internal = false
base_classes = Array[Resource]([SubResource("Resource_74nl1")])
class_properties = {}
class_property_descriptions = {}
meta_properties = {
"color": Color(0.8, 0.8, 0.8, 1)
}
node_class = "StaticBody3D"
name_property = ""

[sub_resource type="Resource" id="Resource_imx0w"]
script = SubResource("GDScript_ly3ma")
spawn_type = 2
origin_type = 4
build_visuals = true
use_in_baked_light = true
shadow_casting_setting = 1
build_occlusion = false
render_layers = 1
collision_shape_type = 0
collision_layer = 1
collision_mask = 1
collision_priority = 1.0
collision_shape_margin = 0.04
classname = "func_detail_illusionary"
description = "Static geometry with no collision. Builds a Node3D with a MeshInstance3D. Does not occlude other VisualInstance3D nodes."
func_godot_internal = false
base_classes = Array[Resource]([SubResource("Resource_74nl1")])
class_properties = {}
class_property_descriptions = {}
meta_properties = {
"color": Color(0.8, 0.8, 0.8, 1)
}
node_class = "Node3D"
name_property = ""

[sub_resource type="Resource" id="Resource_l4h1d"]
script = SubResource("GDScript_ly3ma")
spawn_type = 2
origin_type = 4
build_visuals = true
use_in_baked_light = true
shadow_casting_setting = 1
build_occlusion = true
render_layers = 1
collision_shape_type = 0
collision_layer = 1
collision_mask = 1
collision_priority = 1.0
collision_shape_margin = 0.04
classname = "func_illusionary"
description = "Static geometry with no collision. Builds a Node3D with a MeshInstance3D and an Occluder3D to aid in render culling of other VisualInstance3D nodes."
func_godot_internal = false
base_classes = Array[Resource]([SubResource("Resource_74nl1")])
class_properties = {}
class_property_descriptions = {}
meta_properties = {
"color": Color(0.8, 0.8, 0.8, 1)
}
node_class = "Node3D"
name_property = ""

[sub_resource type="GDScript" id="GDScript_arf4q"]
script/source = "@tool
@icon(\"res://addons/func_godot/icons/icon_godot_ranger.svg\")
## [Resource] file used to express a set of [FuncGodotFGDEntity] definitions. Can be exported as an FGD file for use with a Quake map editor. Used in conjunction with a [FuncGodotMapSetting] resource to generate nodes in a [FuncGodotMap] node.
class_name FuncGodotFGDFile
extends Resource

## Supported map editors enum, used in conjunction with [member target_map_editor].
enum FuncGodotTargetMapEditors {
	OTHER,
	TRENCHBROOM,
	JACK,
	NET_RADIANT_CUSTOM,
}

## Builds and exports the FGD file.
@export var export_file: bool:
	get:
		return export_file # TODO Converter40 Non existent get function
	set(new_export_file):
		if new_export_file != export_file:
			do_export_file(target_map_editor)

func do_export_file(target_editor: FuncGodotTargetMapEditors = FuncGodotTargetMapEditors.TRENCHBROOM, fgd_output_folder: String = \"\") -> void:
	if not Engine.is_editor_hint():
		return
	
	if fgd_output_folder.is_empty():
		fgd_output_folder = FuncGodotLocalConfig.get_setting(FuncGodotLocalConfig.PROPERTY.FGD_OUTPUT_FOLDER) as String
	if fgd_output_folder.is_empty():
		print(\"Skipping export: No game config folder\")
		return

	if fgd_name == \"\":
		print(\"Skipping export: Empty FGD name\")

	var fgd_file = fgd_output_folder + \"/\" + fgd_name + \".fgd\"

	print(\"Exporting FGD to \", fgd_file)
	var file_obj := FileAccess.open(fgd_file, FileAccess.WRITE)
	file_obj.store_string(build_class_text(target_editor))
	file_obj.close()

@export_group(\"Map Editor\")

## Some map editors do not support the features found in others 
## (ex: TrenchBroom supports the \"model\" key word while others require \"studio\", 
## J.A.C.K. uses the \"shader\" key word while others use \"material\", etc...). 
## If you get errors in your map editor, try changing this setting and re-exporting. 
## This setting is overridden when the FGD is built via the Game Config resource.
@export var target_map_editor: FuncGodotTargetMapEditors = FuncGodotTargetMapEditors.TRENCHBROOM

# Some map editors do not support the \"model\" key word and require the \"studio\" key word instead. 
# If you get errors in your map editor, try changing this setting. 
# This setting is overridden when the FGD is built via the Game Config resource.
#@export var model_key_word_supported: bool = true

@export_group(\"FGD\")

## FGD output filename without the extension.
@export var fgd_name: String = \"FuncGodot\"

## Array of [FuncGodotFGDFile] resources to include in FGD file output. All of the entities included with these FuncGodotFGDFile resources will be prepended to the outputted FGD file.
@export var base_fgd_files: Array[Resource] = []

## Array of resources that inherit from [FuncGodotFGDEntityClass]. This array defines the entities that will be added to the exported FGD file and the nodes that will be generated in a [FuncGodotMap].
@export var entity_definitions: Array[Resource] = []

func build_class_text(target_editor: FuncGodotTargetMapEditors = FuncGodotTargetMapEditors.TRENCHBROOM) -> String:
	var res : String = \"\"

	for base_fgd in base_fgd_files:
		if base_fgd is FuncGodotFGDFile:
			res += base_fgd.build_class_text(target_editor)
		else:
			printerr(\"Base Fgd Files contains incorrect resource type! Should only be type FuncGodotFGDFile.\")
	
	var entities = get_fgd_classes()
	for ent in entities:
		if not ent is FuncGodotFGDEntityClass:
			continue
		if ent.func_godot_internal:
			continue
		
		var ent_text = ent.build_def_text(target_editor)
		res += ent_text
		if ent != entities[-1]:
			res += \"\\n\"
	return res

## This getter does a little bit of validation. Providing only an array of non-null uniquely-named entity definitions
func get_fgd_classes() -> Array:
	var res : Array = []
	for cur_ent_def_ind in range(entity_definitions.size()):
		var cur_ent_def = entity_definitions[cur_ent_def_ind]
		if cur_ent_def == null:
			continue
		elif not (cur_ent_def is FuncGodotFGDEntityClass):
			printerr(\"Bad value in entity definition set at position %s! Not an entity defintion.\" % cur_ent_def_ind)
			continue
		res.append(cur_ent_def)
	return res

func get_entity_definitions() -> Dictionary:
	var res : Dictionary = {}

	for base_fgd in base_fgd_files:
		var fgd_res = base_fgd.get_entity_definitions()
		for key in fgd_res:
			res[key] = fgd_res[key]

	for ent in get_fgd_classes():
		# Skip entities without classnames
		if ent.classname.replace(\" \",\"\") == \"\":
			printerr(\"Skipping \" + ent.get_path() + \": Empty classname\")
			continue
		
		if ent is FuncGodotFGDPointClass or ent is FuncGodotFGDSolidClass:
			var entity_def = ent.duplicate()
			var meta_properties := {}
			var class_properties := {}
			var class_property_descriptions := {}

			for base_class in _generate_base_class_list(entity_def):
				for meta_property in base_class.meta_properties:
					meta_properties[meta_property] = base_class.meta_properties[meta_property]

				for class_property in base_class.class_properties:
					class_properties[class_property] = base_class.class_properties[class_property]

				for class_property_desc in base_class.class_property_descriptions:
					class_property_descriptions[class_property_desc] = base_class.class_property_descriptions[class_property_desc]

			for meta_property in entity_def.meta_properties:
				meta_properties[meta_property] = entity_def.meta_properties[meta_property]

			for class_property in entity_def.class_properties:
				class_properties[class_property] = entity_def.class_properties[class_property]

			for class_property_desc in entity_def.class_property_descriptions:
				class_property_descriptions[class_property_desc] = entity_def.class_property_descriptions[class_property_desc]

			entity_def.meta_properties = meta_properties
			entity_def.class_properties = class_properties
			entity_def.class_property_descriptions = class_property_descriptions

			res[ent.classname] = entity_def
	return res

func _generate_base_class_list(entity_def : Resource, visited_base_classes = []) -> Array:
	var base_classes : Array = []

	visited_base_classes.append(entity_def.classname)

	# End recursive search if no more base_classes
	if len(entity_def.base_classes) == 0:
		return base_classes

	# Traverse up to the next level of hierarchy, if not already visited
	for base_class in entity_def.base_classes:
		if not base_class.classname in visited_base_classes:
			base_classes.append(base_class)
			base_classes += _generate_base_class_list(base_class, visited_base_classes)
		else:
			printerr(str(\"Entity '\", entity_def.classname,\"' contains cycle/duplicate to Entity '\", base_class.classname, \"'\"))

	return base_classes
"

[sub_resource type="Resource" id="Resource_jk3v4"]
script = SubResource("GDScript_arf4q")
export_file = false
target_map_editor = 1
fgd_name = "FuncGodot"
base_fgd_files = Array[Resource]([])
entity_definitions = Array[Resource]([SubResource("Resource_74nl1"), SubResource("Resource_4tp8u"), SubResource("Resource_c64xc"), SubResource("Resource_qclf3"), SubResource("Resource_imx0w"), SubResource("Resource_l4h1d")])

[resource]
script = SubResource("GDScript_arf4q")
export_file = false
target_map_editor = 1
fgd_name = "Paper Doll"
base_fgd_files = Array[Resource]([SubResource("Resource_jk3v4")])
entity_definitions = Array[Resource]([])
